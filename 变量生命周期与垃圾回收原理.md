# 垃圾回收机制
`JavaScript`不需要手动清除垃圾回收，`JavaScript`引擎是包含垃圾回收机制的引擎
## 垃圾回收机制的原理
1. 找出不再使用的变量
2. 释放该变量占用的内存
3. 引擎会在固定的时间执行垃圾回收
## 变量的生命周期
我们所讨论的的变量的生命周期，实际上讨论的是函数内部的变量，也就是说是局部变量。因为全局变量的生命周期在逻辑上来说，只有浏览器关闭的时候全局变量才会销毁。
局部变量只在函数执行的时候存在，当函数执行完成后局部变量被销毁（AO执行期上下文被销毁）
# 垃圾回收机制的策略
## 标记清除方式(mark and sweep)
局部变量a进入环境打上标记，当局部变量a离开环境的时候打上标记，垃圾回收机制会在一定的间隔内进行清除，首先垃圾回收机制会排除，并且排除闭包（这里指的应该是，而非）所形成的那些AO里边儿的那些变量。然后如果排除以后还仍然存在的离开标记状态的变量就被视为删除的变量。
```javascript
function test() {
  var a = 0; // 变量a进入环境
}
test(); // 变量a离开环境

var b = 1;
var c = 2;
function e() {}
```
## 引用计数方式(reference counting)
引用技术方法，就是将引用值进行计数。例如下面的例子中：变量a/b分别引用new Object()的值，所以此时a、b分别被计数为1，当计数的值为0的时候，垃圾回收机制会自动清除这些变量。
但是问题是，存在循环引用的问题，比如下面a.prop = b, b.prop = a这样的问题，此时按照引用计数的方式a = 2, b = 2。那么这两个变量a、b由于计数值始终都是2，所以垃圾回收机制并不能够回收这两个变量，所以低版本的IE浏览器会经常出现内存泄漏的问题。
解决这个问题，就需要我们手动的。a = null、b = null。
```javascript
function test() {
  var a = new Object(); // a = 1
  var b = new Object(); // b = 1
  var c = a; // a++ = 2;
  var c = b; // a-- = 1;

  // 循环引用
  a.prop = b; // b = 2;
  b.prop = a; // a = 2;

  // 解除引用
  a = null;
  b = null;
}
```